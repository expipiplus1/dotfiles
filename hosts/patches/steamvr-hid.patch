diff --git a/drivers/hid/hidraw.c b/drivers/hid/hidraw.c
index 79faac87a06f..3650dea2884a 100644
--- a/drivers/hid/hidraw.c
+++ b/drivers/hid/hidraw.c
@@ -27,6 +27,7 @@
 #include <linux/mutex.h>
 #include <linux/sched/signal.h>
 #include <linux/string.h>
+#include <linux/mm.h>
 
 #include <linux/hidraw.h>
 
@@ -34,7 +35,7 @@ static int hidraw_major;
 static struct cdev hidraw_cdev;
 static struct class *hidraw_class;
 static struct hidraw *hidraw_table[HIDRAW_MAX_DEVICES];
-static DEFINE_MUTEX(minors_lock);
+static struct mutex* minors_locks;
 
 static ssize_t hidraw_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
 {
@@ -107,7 +108,7 @@ static ssize_t hidraw_send_report(struct file *file, const char __user *buffer,
 	__u8 *buf;
 	int ret = 0;
 
-	lockdep_assert_held(&minors_lock);
+	lockdep_assert_held(minors_locks + minor);
 
 	if (!hidraw_table[minor] || !hidraw_table[minor]->exist) {
 		ret = -ENODEV;
@@ -159,10 +160,11 @@ static ssize_t hidraw_send_report(struct file *file, const char __user *buffer,
 
 static ssize_t hidraw_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
 {
+	unsigned int minor = iminor(file_inode(file));
 	ssize_t ret;
-	mutex_lock(&minors_lock);
+	mutex_lock(minors_locks + minor);
 	ret = hidraw_send_report(file, buffer, count, HID_OUTPUT_REPORT);
-	mutex_unlock(&minors_lock);
+	mutex_unlock(minors_locks + minor);
 	return ret;
 }
 
@@ -182,7 +184,7 @@ static ssize_t hidraw_get_report(struct file *file, char __user *buffer, size_t
 	int ret = 0, len;
 	unsigned char report_number;
 
-	lockdep_assert_held(&minors_lock);
+	lockdep_assert_held(minors_locks + minor);
 
 	if (!hidraw_table[minor] || !hidraw_table[minor]->exist) {
 		ret = -ENODEV;
@@ -272,7 +274,7 @@ static int hidraw_open(struct inode *inode, struct file *file)
 		goto out;
 	}
 
-	mutex_lock(&minors_lock);
+	mutex_lock(minors_locks + minor);
 	if (!hidraw_table[minor] || !hidraw_table[minor]->exist) {
 		err = -ENODEV;
 		goto out_unlock;
@@ -301,7 +303,7 @@ static int hidraw_open(struct inode *inode, struct file *file)
 	spin_unlock_irqrestore(&hidraw_table[minor]->list_lock, flags);
 	file->private_data = list;
 out_unlock:
-	mutex_unlock(&minors_lock);
+	mutex_unlock(minors_locks + minor);
 out:
 	if (err < 0)
 		kfree(list);
@@ -347,7 +349,7 @@ static int hidraw_release(struct inode * inode, struct file * file)
 	struct hidraw_list *list = file->private_data;
 	unsigned long flags;
 
-	mutex_lock(&minors_lock);
+	mutex_lock(minors_locks + minor);
 
 	spin_lock_irqsave(&hidraw_table[minor]->list_lock, flags);
 	list_del(&list->node);
@@ -356,7 +358,7 @@ static int hidraw_release(struct inode * inode, struct file * file)
 
 	drop_ref(hidraw_table[minor], 0);
 
-	mutex_unlock(&minors_lock);
+	mutex_unlock(minors_locks + minor);
 	return 0;
 }
 
@@ -369,7 +371,7 @@ static long hidraw_ioctl(struct file *file, unsigned int cmd,
 	struct hidraw *dev;
 	void __user *user_arg = (void __user*) arg;
 
-	mutex_lock(&minors_lock);
+	mutex_lock(minors_locks + minor);
 	dev = hidraw_table[minor];
 	if (!dev || !dev->exist) {
 		ret = -ENODEV;
@@ -487,7 +489,7 @@ static long hidraw_ioctl(struct file *file, unsigned int cmd,
 		ret = -ENOTTY;
 	}
 out:
-	mutex_unlock(&minors_lock);
+	mutex_unlock(minors_locks + minor);
 	return ret;
 }
 
@@ -546,18 +548,21 @@ int hidraw_connect(struct hid_device *hid)
 
 	result = -EINVAL;
 
-	mutex_lock(&minors_lock);
-
 	for (minor = 0; minor < HIDRAW_MAX_DEVICES; minor++) {
+		mutex_lock(minors_locks + minor);
+
 		if (hidraw_table[minor])
+		{
+			mutex_unlock(minors_locks + minor);
 			continue;
+		}
+
 		hidraw_table[minor] = dev;
 		result = 0;
 		break;
 	}
 
 	if (result) {
-		mutex_unlock(&minors_lock);
 		kfree(dev);
 		goto out;
 	}
@@ -567,7 +572,7 @@ int hidraw_connect(struct hid_device *hid)
 
 	if (IS_ERR(dev->dev)) {
 		hidraw_table[minor] = NULL;
-		mutex_unlock(&minors_lock);
+		mutex_unlock(minors_locks + minor);
 		result = PTR_ERR(dev->dev);
 		kfree(dev);
 		goto out;
@@ -583,7 +588,7 @@ int hidraw_connect(struct hid_device *hid)
 	dev->exist = 1;
 	hid->hidraw = dev;
 
-	mutex_unlock(&minors_lock);
+	mutex_unlock(minors_locks + minor);
 out:
 	return result;
 
@@ -594,16 +599,17 @@ void hidraw_disconnect(struct hid_device *hid)
 {
 	struct hidraw *hidraw = hid->hidraw;
 
-	mutex_lock(&minors_lock);
+	mutex_lock(minors_locks + hidraw->minor);
 
 	drop_ref(hidraw, 1);
 
-	mutex_unlock(&minors_lock);
+	mutex_unlock(minors_locks + hidraw->minor);
 }
 EXPORT_SYMBOL_GPL(hidraw_disconnect);
 
 int __init hidraw_init(void)
 {
+	unsigned i;
 	int result;
 	dev_t dev_id;
 
@@ -627,6 +633,13 @@ int __init hidraw_init(void)
 	if (result < 0)
 		goto error_class;
 
+	minors_locks = kmalloc(sizeof(struct mutex) * HIDRAW_MAX_DEVICES, GFP_KERNEL);
+	if (minors_locks == NULL)
+		goto error_class;
+
+	for (i = 0; i < HIDRAW_MAX_DEVICES; i++)
+		mutex_init(minors_locks + i);
+
 	pr_info("raw HID events driver (C) Jiri Kosina\n");
 out:
 	return result;
@@ -646,4 +659,5 @@ void hidraw_exit(void)
 	class_destroy(hidraw_class);
 	unregister_chrdev_region(dev_id, HIDRAW_MAX_DEVICES);
 
+	kvfree(minors_locks);
 }
